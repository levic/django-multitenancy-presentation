<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/sky.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/a11y-light.css">

		<style>
			.reveal h1,
			.reveal h2,
			.reveal h3,
			.reveal h4,
			.reveal h5,
			.reveal h6
			{
				text-align: center;
			}

			.reveal section.left {
				/*display: block;*/
				text-align: left;
			}

			.hidden {
				visibility: hidden;
			}

			.figure img {
				display: block;
				margin: 0 auto;
			}

		</style>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">

				<!-- =============================================================== -->
				<section>
					<h1 class="r-fit-text">Multi-Tenancy<br/>Strategies<br/>with<br/>Django+PostgreSQL</h1>
				</section>

				<section>
					<h2>Problem Statement</h2>
					<p class="fragment fade-in">We've using Django & PostgreSQL on our website.</p>
					<p class="fragment fade-in">How can we ensure users don't see data that doesn't belong to them?</p>
					<p class="fragment fade-in">"<em>Tenant</em>"?</p>

					<aside class="notes">
						- Particular focus: what can we do to ensure that developer mistakes don't allow data leakage?<br/>

						- What is a "tenant"? User or company that has data that is
							logically isolated from other tenants in the system
							- One example would be gmail where users should not be able to see data from other users even though
								using the same server resources
						- More than just a user. Consider something like Salesforce where many users from the same company can see
						  the company's data, but they shouldn't be able to see the data from other companies using Salesforce
					</aside>
				</section>

				<section>
					<h2>Talk Outline</h2>
					<ol>
						<li>Django permissions</li>
						<li>Multiple app servers</li>
						<li>Multiple databases</li>
						<li><b>Single database</b></li>
					</ol>

					<aside class="notes">
						Will spend most time on the last one because that's the most interesting

						Assumptions: python devs who have basic familiarity with django's ORM
					</aside>
				</section>

				<!-- =============================================================== -->
				<section>
					<section class="left">
						<h2>Django Permissions</h2>
						<div>
							<p>Default System:</p>
							<pre>
								<code data-trim data-noescape class="language-python">
									user.has_perm("my_app.change_book")
								</code>
							</pre>
							<ul>
								<li class="fragment fade-in">Quite Limited</li>
							</ul>
						</div>

						<aside class="notes">
							When first start using django, start out by following tutorials & docs; they usually start with the vanilla django permission system<br/>
							Limited usefulness:<br/>
							- All permissions are global: a user either has them or they don't; can't restrict to a subset of records
							- Can't attach any logic to permissions which usually leads to code duplication
							- Clumsy to define permissions that aren't add/change/delete/view
							- Assumes permissions are linked to a model: what if you have eg a dashboard?
							- Permission assignments are stored in the database, not code
								- Needs migrations to change
								- Hard to properly test if you've allowed users to change permission
						</aside>
					</section>

					<section class="left">
						<h2>Django Permissions</h2>
						<div>
							<p>Alternative:</p>
							<pre>
								<code data-trim data-noescape>
									user.has_perm("my_app.change_book", book)
								</code>
							</pre>
							<ul>
								<li class="fragment fade-in">Can use 3rd-party packages (eg <code>rules</code>)</li>
								<li class="fragment fade-in">Roll your own <code>AUTHENTICATION_BACKEND</code></li>
								<li class="fragment fade-in">Update CBVs to use object-based permissions
									<ul>
										<li class="fragment fade-in">Django System Checks</li>
									</ul>
								</li>
							</ul>
						</div>

						<aside class="notes">
							- Fortunately django's permission system does actually support record-level permission
							- Unfortunately it's not something that django supports out of the box
								- To take advantage of it you have to configure an authentication backend

							- `rules` allows you to map a permission name to a python function and its structure encourages you to centralise all your permission checking logic
							- Creating your own AUTHENTICATION_BACKEND is surprisingly simple: `has_perm`
								- On previous projects for example I've used a permissions system that looks up permissions in a CSV file which is then used to invoke python functions.
									This  has the nice property that your product manager can easily see which user types have access to which permissions

							- One of the nice things about CBVs is that you can implement
								object-based permission checks in your base classes and then you
								get this throughout your site
								- Do want to be careful that if new developers don't accidentally
							    inherit from the vanilla django CBVs; if you've never used it
							    before then look up Django System Checks which will allow you
							    to run system check on startup so that you can be sure this
									didn't take place
						</aside>
					</section>
				</section>

				<!-- =============================================================== -->
				<section>
					<section class="left">
						<h2 class="r-fit-text">Multiple App Servers<br/>&amp; Databases</h2>
						<div class="figure">
							<img src="figures/fig-multi-multidb.svg" />
						</div>

						<aside class="notes">
							- First major strategy
							- each tenant gets their own app server and their own database on completely separate domains
						</aside>
					</section>
					<section>
						<h2 class="r-fit-text">Multiple App Servers<br/>&amp; Databases</h2>
						<div>
							<ul>
								<li><span class="fragment fade-in">✅</span> Code Simplicity</li>
								<li><span class="fragment fade-in">✅</span> Isolation</li>
								<li><span class="fragment fade-in">❌</span> Scalability</li>
								<li><span class="fragment fade-in">❌</span> Cross-Tenancy Queries</li>
								<li><span class="fragment fade-in">❌</span> Administration, Deployment</li>
							</ul>
						</div>

						<aside class="notes">
							- code is simple.
								- very difficult for devs to make a mistake and accidentally expose data from another tenancy<br/>
							- isolation:
								- performance (one big tenant doesn't affect others)
								- cost<br/>
							- scalability:
								- scalability in terms of number of tenants
								- if each tenancy gets a new DB server, cost will be dramatically higher
								- OTOH if each tenancy is a new DB on a shared server then there's no performance isolation & DB overheads start to matter<br/>
							- cross-tenancy
								- no easy way to run queries that aggregate data from all tenancies<br/>
							- admin: how to take a DB snapshot?<br/>
							- deployments: have to roll out migrations to each tenancy one at a time<br/>

							Usually this is a bad idea<br/>

							why mention this at all? can be a good idea if you have a small number of tenants;
							I worked with a client who licensed their CRM to some competitors in a different locations; only 3 copies
							when one of those inevitably decided to fork the system it was very straightforward

						</aside>

					</section>
				</section>

				<!-- =============================================================== -->
				<section>
					<section class="left">
						<h2 class="r-fit-text">Multiple Databases</h2>
						<div class="figure">
							<img src="figures/fig-single-multidb.svg" />
						</div>

						<aside class="notes">
							- single django app server that uses middleware to examine incoming requests and direct to a new database per tenant
						</aside>

					</section>
					<section class="left">
						<h2 class="r-fit-text">Multiple Databases</h2>
						<div>
							<ul>
								<li><span class="fragment fade-in">✅</span> Code Simplicity</li>
								<li><span class="fragment fade-in">✅</span> Good Isolation </li>
								<li><span class="fragment fade-in">❌</span> Scalability</li>
								<li><span class="fragment fade-in">❌</span> Cross-Tenancy Queries</li>
								<li><span class="fragment fade-in">❌</span> Administration, Deployment</li>
							</ul>
						</div>

						<aside class="notes">
							- inherits almost all of the advantages and disadvantages of having multiple app servers,
							  but you do save on app server hosting
								- in particular: how are you going to handle the situation where migrations fail on
									tenancy 1,500 out of 3,000? transactions can't cross databases so there's no easy rollback.
						</aside>
					</section>
				</section>

				<section>
					<section class="left">
						<h2 class="r-fit-text">Multiple <strike>Databases</strike> Schemas</h2>
						<div class="figure">
							<img src="figures/fig-single-multischema.svg" />
						</div>

						<aside class="notes">
							- A nicer variation of this is to use on schema per tenant
							- If you've not used schemas before, they are postgres' equivalent of namespaces
								- Conceptually you can think of these as mini databases within a real database
								- The table definitions inside each schema are entirely independent of one another
							- Again the idea here is that middleware examines the request and sets a connection-level variable in
							  postgres which directs it to use the correct schema for the tenant
						</aside>
					</section>

					<section class="left">
						<h2 class="r-fit-text">Multiple Schemas</h2>
						<div>
							<ul>
								<li><span class="fragment fade-in">✅</span> Code Simplicity</li>
								<li><span class="fragment fade-in">✅</span> Isolation </li>
								<li><span class="fragment fade-in">*️⃣</span> Scalability</li>
								<li><span class="fragment fade-in">*️⃣</span> Cross-Tenancy Queries</li>
								<li><span class="fragment fade-in">*️⃣</span> Administration, Deployment</li>
								<li class="fragment fade-in">⚠️ Transaction limits, connection pooling</li>
								<li class="fragment fade-in"><code>django-tenants</code></li>
							</ul>
						</div>

						<aside class="notes">
							- Again, majority of code can pretend that tenancies don't exist at all and it "just works"<br/>
							- scalability
									- post overhead per schema/table. can be an issue if you have lots of schemas
									- very large numbers of schemas:
										- pg tools (pg_dump, pg_restore) can fail on default settings with very large number of items (20k)<br/>
							- Cross-Tenancy Queries: possible because the tables are all in the same database,
								however you could end up with rather large SQL UNIONs to actually make that happen<br/>
							- deployment issues:
								- transaction limits in postgres; if you try to modify too many tables in one transaction
									you will run into those limits
								- now back to the earlier problem where you might have migrations applied to half of the system when something fails<br/>
							- if connection pooling: will work but you need to make sure you have your settings correct so that you
								don't interleave requests on the same connection between tenants<br/>
							- if you've not used it before, connection pooling is where instead
							  of creating a new connection to the DB on every request you reuse
								the same connection between requests; depending on the configuration
							  you can even reuse the same connection for two simultaneous requests<br/>

							- django-tenants maps a subdomain to a database schema and has the middleware already written for you

							- table inheritance PG feature at first useful until you realise that FKs & unique constraints don't work
						</aside>

					</section>
				</section>

				<!-- =============================================================== -->
				<section>

					<section class="left">
						<h2 class="r-fit-text">Single Database</h2>
						<div class="figure">
							<img src="figures/fig-single-shared.svg" />
						</div>
					</section>

					<section class="left">
						<h2 class="r-fit-text">Single Database</h2>
						<div>
							<ul>
								<li>Django Managers</li>
								<li>Denormalising Tenancy</li>
								<li>Postgres Row-Level Security</li>
							</ul>
						</div>

						<aside class="notes">
							- single app server and single database, all tenants are stored
								the same tables is probably the most common way of implementing
								multi-tenancy
							- in order to keep tenants separate from each other there are
								number of different strategies that you can folow
						</aside>
					</section>

					<section class="left">
						<h2 class="r-fit-text">Single Database</h2>
						<div>
							<ul>
								<li><span class="fragment fade-in">❌</span> Code Simplicity</li>
								<li><span class="fragment fade-in">*️⃣</span> Isolation</li>
								<li><span class="fragment fade-in">✅</span> Scalability</li>
								<li><span class="fragment fade-in">✅</span> Cross-Tenancy Queries</li>
								<li><span class="fragment fade-in">✅</span> Administration, Deployment</li>
							</ul>
						</div>

						<aside class="notes">
							- code not as simple, you always have to be aware of the fact that
								multiple tenants are in the same tables<br/>
							- isolation is not great; in particular coding mistakes can expose
								data from the wrong tenant<br/>
							however<br/>
							- scalability with number of tenants is generally excellent<br/>
							- cross-tenancy queries are so easy that the bigger problem is
								accidentally doing cross-tenancy queries
						</aside>

					</section>

				</section>

				<!-- =============================================================== -->
				<section>

					<section class="left" data-transition="fade-out">
						<h2 class="r-fit-text">Custom Model Managers</h2>

						<div class="figure">
							<img src="figures/fig-er-diagram.svg" />
						</div>

						<div>
							<pre>
								<code data-trim data-noescape class="language-python">
									class ProjectQuerySet(QuerySet):
										def filter_tenant(queryset, account):
											return self.queryset.filter(account=account)

									class Project(Model):
										objects = Manager.from_queryset(ProjectQuerySet)()
								</code>
							</pre>
						</div>
					</section>

					<section class="left" data-transition="fade-in slide-out">
						<h2 class="r-fit-text">Custom Model Managers</h2>

						<div class="figure">
							<img src="figures/fig-er-diagram.svg" />
						</div>

						<div>
							<pre>
								<code data-trim data-noescape class="language-python">
									class SubtaskQuerySet(QuerySet):
										def filter_tenant(queryset, account):
											return self.queryset.filter(task__project__account=account)

									class Subtask(Model):
										objects = Manager.from_queryset(SubtaskQuerySet)()
								</code>
							</pre>
						</div>

						<aside class="notes">
							- Idea here is having a standard interface on every queryset &
								model manager which will apply a tenancy filter, and we use this
								as the default models' managers<br/>
								Nice consequences of standardising is that your base
								classes CBVs can always call the same filtering function<br/>
							- If a table doesn't directly join to your tenancy table then
								you just use the ORM's table traversal to get there.<br/>
							- ?? If you really want to be clever then your models can define
								a DAG leading back to the tenancy table and the joins can be
								generated automatically
						</aside>

					</section>

					<section class="left">
						<h2 class="r-fit-text">Custom Model Managers</h2>
						<ul>
							<li class="fragment fade-in">⚠️ Non-ORM queries</li>
							<li class="fragment fade-in">⚠️ Aggregate queries</li>
							<li class="fragment fade-in">⚠️️ FK Leakage:
								<pre>
								<code data-trim data-noescape class="language-python">
									user.country.user_set
								</code>
							</pre>
							</li>
							<li class="fragment fade-in">⚠️️ Forget to call <code>filter_tenant</code></li>
						</ul>


						<aside class="notes">
							- Caveats here: if you write custom SQL outside the ORM then you're on your own<br/>
							- Having the join can change the behaviour of some django ORM aggregate queries;
								it's a fairly rare circumstance but sometimes you'll need to do the filters in another manner<br/>
							- A more subtle problem is that by default any FKs in django will
							  also create reverse FKs on the model.
							<br/>
							- If you want to be strict you can use Django System Checks to
							  verify that FKs on models have reverse FKs disabled<br/>
							- Practical matter: current tenant ID will be in the request or
							  attached the request user; painful to have to pass this
								down potentially very many layers of code from the request so
								you maay probably some Middleware to keep track of the current
							  tenant in thread-local storage.<br/>
							- How do we ensure that developers don't forget to call filter_tenant()?<br/>
						</aside>

					</section>

					<section class="left">
						<h2 class="r-fit-text">Mandatory Tenant Filtering</h2>
						<ul>
							<li class="fragment fade-in">Remember whether <code>filter_tenant</code> was called</li>
							<li class="fragment fade-in">Log a warning or Raise an exception</li>
							<li class="fragment fade-in">️️⚠️️ <code>_default_manager</code> vs <code>_base_manager</code>
								<pre>
									<code data-trim data-noescape class="language-python">
										class Project(Model):
											objects = ProjectManager(require_filter_tenant=True)
											all_tenants = ProjectManager(require_filter_tenant=False)

											class Meta:
												base_manager_name = "all_tenants"
									</code>
								</pre>
							</li>
						</ul>


						<aside class="notes">
							- if make this mandatory you'll quickly run across the difference<br/>
								between django's base manager and its default manager<br/>
							<br/>
							- you need to provide some mechanism to bypass mandatory filters
							- base vs default manager<br/>
								- refresh_from_db()<br/>
								- migrations<br/>
								- fetching FK relationships<br/>
						</aside>
					</section>

				</section>

				<!-- =============================================================== -->
				<section>
					<section class="left" data-transition="fade-out">
						<h2 class="r-fit-text">Tenancy Denormalisation</h2>
						<div class="figure">
							<img src="figures/fig-er-diagram-pk.svg" />
						</div>
						<aside class="notes">
							- normally we want out database to be normalised <br/>
							- if we need to filter according to the tenant then we join one or
							  more times until we get back to the table that contains the root
							  tenancy information<br/>
						</aside>
					</section>

					<section class="left" data-transition="fade-in slide-out">
						<h2 class="r-fit-text">Tenancy Denormalisation</h2>
						<div class="figure">
							<img src="figures/fig-er-diagram-pk-denorm.svg" />
						</div>

						<aside class="notes">
							- something we can do is to denormalise and copy the tenant ID into every table<br/>
						</aside>
					</section>


					<section class="left">
						<h2 class="r-fit-text">Tenancy Denormalisation</h2>
						<ul>
							<li><span class="fragment fade-in">*️⃣</span> Code Simplicity</li>
							<li><span class="fragment fade-in">*️⃣</span> Isolation</li>
							<li><span class="fragment fade-in">✅</span> Scalability</li>
							<li><span class="fragment fade-in">✅</span> Cross-Tenancy Queries</li>
							<li><span class="fragment fade-in">✅</span> Administration, Deployment</li>
							<li class="fragment fade-in">⚠️️ Harder to move data between tenants</li>
							<li class="fragment fade-in">Standard denormalisation caveats</li>
							<li class="fragment fade-in"><code>django-multitenant</code></li>
						</ul>

						<aside class="notes">
							- WHY? simpler code (no joins; aggregate queries aren't going to
							  be affected by joins), and opens up some possibilities later<br/>
							- doesn't directly affect isolation<br/>
							- in most cases it will improve scalability due to fewer joins<br/>
							- harder to move data between tenants compared to a normalised schema<br/>

							- denormalisation caveats: if your tables all have FK relationships to the tenant
								and you modify a tenant record then postgres has to update a lot more index data
							  <br/>
								You could store the tenant ID as an ordinary indexed integer instead of a FK,<br/>
								or just store only the bare minimum of data in the tenant table, so that those updates are very infrequent
							<br/>

							- nice 3rd party package called django-multitenant: which assumes your
							  tenant ID has been denormalised and will add WHERE clauses onto
							  every ORM query. This also overrides the standard django FK field
							  to fix the FK traversal issue that I spoke about earlier<br/>
							- Also worth mentioning is that the reason for this project is
								that the company behind it makes a PG extension that
								transparently shards your data between multiple postgres servers
								using the denormalised tenant ID; Microsoft bought them and now
								that's been rolled that into Azure as CosmosDB for PostgreSQL.
						</aside>

					</section>

				</section>


				<!-- =============================================================== -->
				<section>

					<section class="left" data-transition="fade-out">
						<h2 class="r-fit-text">Postgres Row-level Security</h2>
						<div>
							<pre>
								<code data-trim data-noescape class="language-sql">
									ALTER TABLE project ENABLE ROW LEVEL SECURITY;

									CREATE POLICY project_policy
									  ON project
									  USING (your expression goes here);
								</code>
							</pre>
						</div>

						<aside class="notes">
							- Postgres has the ability to add security checks on a row-by-row
							  basis to each table
						</aside>
					</section>

					<section class="left" data-transition="fade-out fade-in">
						<h2 class="r-fit-text">Postgres Row-level Security</h2>
						<div>
							<pre>
								<code data-trim data-noescape class="language-sql">
									ALTER TABLE project ENABLE ROW LEVEL SECURITY;

									CREATE POLICY project_policy
									  ON project
									  USING account_id = current_user::INT;
								</code>
							</pre>
						</div>

						<ul>
							<li class="fragment fade-in">⚠️️ Users are global</li>
						</ul>

						<aside class="notes">
							- One strategy you could follow is to add a new postgres user
							  for every tenant, where the user name is the tenant ID<br/>
							- Requires you to have denormalised the tenant ID into the table<br/>
							- current_user is a string.<br/>
							- One of the more restrictive aspects is that this requires you
							  to create a new user for every tenant; while this can be,
								automated, users are global (not specific to one database),
								and it's not uncommon for you to not have permissions to
							  create new users in postgres<br/>

						</aside>
					</section>


					<section class="left" data-transition="slide-out fade-in">
						<h2 class="r-fit-text">Postgres Row-level Security</h2>
						<div>
							<pre>
								<code data-trim data-noescape class="language-sql">
									ALTER TABLE project ENABLE ROW LEVEL SECURITY;

									CREATE POLICY project_policy
									  ON project
										USING account_id = current_setting('django.account_id')::INT;
								</code>
							</pre>
						</div>

						<aside class="notes">
							- A nicer strategy is to have some middleware set a variable on the
								PG connection to the current tenant ID<br/>
							- In this example we've set `django.account_id`.
							  The dot in the var name is important. We're actually
							  abusing the fact that this is how custom postgres
							  extension modules are configured; postgres thinks that this is
								a config setting for a module called "django" that we just
								haven't loaded yet
						</aside>

					</section>

					<section class="left" data-transition="slide-out fade-in">
						<h2 class="r-fit-text">Postgres Row-level Security</h2>
						<div>Caveats</div>
						<ul>
							<li class="fragment fade-in">⚠️ Connection Pooling</li>
							<li class="fragment fade-in">⚠️ Potential performance impact</li>
							<li class="fragment fade-in">⚠️ Backups!</li>
						</ul>

						<aside class="notes">
							- If using connection pooling need to make sure you have this set
							  up correctly so that you don't interleave queries<br/>

							- potential performance issues:
								- optimiser may gets RLS costs wrong and apply in an order you
							    don't want
								- it *is* technically possible to not denormalise and to use
							    sub-SELECTs in your RLS checks instead, but that's even more
									prone to unexpected performance issues
							  - most of the times if your code is already applying correct
							    tenancy filters then this shouldn't be an issue, and is a nice
							    backstop in case you've messed something up<br/>

							- if using postgres users for your RLS checks then make sure that
							  the user taking backups can actually see all rows or
							  you'll be very upset when you go to restore a backup<br/>

						</aside>

					</section>

				</section>

				<!-- =============================================================== -->
				<section>

					<section class="left">
						<h2 class="r-fit-text">Summary</h2>
						<ol>
							<li>Django permissions</li>
							<li>Multiple app servers</li>
							<li>Multiple databases</li>
							<li>Single database
								<ul>
									<li>Django Managers</li>
									<li>Denormalising Tenancy</li>
									<li>Postgres Row-Level Security</li>
								</ul>
							</li>
						</ol>
						<aside class="notes">
							In summary<br/>
							- Talked about using the full capabilty of the django permissions system <br/>
							- Multiple app servers & databases are extremely simple but can be costly<br/>
							- Using a single database scales much better with number of tenants,<br/>
							  - Custom django managers/queryset can be used to standardise on tenancy filtering<br/>
							  - Denormalising tenancy data can simplify your code at the expense of larger tables/indexes and less flexibility<br/>
							  - Postgres row-level security checks can act as a nice failsafe<br/>
						</aside>
					</section>
				</section>

				<!-- =============================================================== -->

				<section>
					<section class="left">
						<h2>Fin</h2>
						<div>
							<img src="images/darcy-wheeler-KycQBvYXFLI-unsplash-small.jpg"/>
						</div>
					</section>

					<section class="left">
						<h2>Questions?</h2>
					</section>
				</section>

				<!-- =============================================================== -->

			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [
					RevealMarkdown,
					RevealHighlight,
					RevealNotes,
				]
			});
		</script>
	</body>
</html>
